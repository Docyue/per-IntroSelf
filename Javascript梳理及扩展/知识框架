Html部分
1、盒子模型
文档中的每个元素被描绘为矩形盒子。确定其大小，属性——比如颜色、背景、边框，及其位置是渲染引擎的目标。CSS下这些矩形盒子由标准盒模型描述。这个模型描述元素内容占用空间。
盒子有四个边界：外边距边界margin edge, 边框边界border edge, 内边距边界padding edge 与 内容边界content edge。
a.内容区域content area 是真正包含元素内容的区域。位于内容边界的内部，它的大小为内容宽度 或 content-box宽及内容高度或content-box高。如果 box-sizing 为默认值， width, min-width, max-width, height, min-height 与 max-height 控制内容大小。
b.内边距区域padding area 用内容及可能的边框之间的空白区域扩展内容区域。它位于内边边界内部，通常有背景——颜色或图片（不透明图片盖住背景颜色）. 它的大小为 padding-box  宽与 padding-box 高。内边距与内容边界之间的空间可以由 padding-top, padding-right, padding-bottom, padding-left 和简写属性 padding 控制。
c.边框区域border area 是包含边框的区域，扩展了内边距区域。它位于边框边界内部，大小为 border-box  宽和 border-box 高。由 border-width 及简写属性 border控制。
d.外边距区域margin area用空白区域扩展边框区域，以分开相邻的元素。它的大小为  margin-box 的高宽。外边距区域大小由 margin-top, margin-right, margin-bottom, margin-left 及简写属性 margin 控制。在 外边距合并 的情况下，由于盒之间共享外边距，外边距不容易弄清楚。
最后注意，对于行内非替换元素，其占用空间（行高）由 line-height 决定，即使有内边距与边框。

2、文档流和文本流
文档流：将窗体自上而下分成一行一行,并在每行中按从左至右的挨次排放元素,即为文档流。每个非浮动块级元素都独有一行, 浮动元素则按规则浮在行的一端. 若当时行容不下, 则另起新行再浮动。内联元素也不会独有一行. 一切元素(包括块级,内联和列表元素)均可生成子行, 用于摆放子元素。
有三种状况将使得元素离开文档流而存在,分别是浮动、绝对定位、固定定位.
然则在IE中浮动元素也存在于文档流中。
浮动元素不占任何正常文档流空间，而浮动元素的定位照样基于正常的文档流，然后从文档流中抽出并尽能够远的挪动至左侧或许右侧。当一个元素脱离正常文档流后，依然在文档流中的其他元素将忽略该元素并填补其原先的空间。 基于文档流，理解以下的定位形式:
相对定位：元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。
绝对定位：即完全离开文档流, 相关于position属性非static值的比来父级元素进行偏移。
固定定位：即完全离开文档流，相关于视区进行偏移。
文本流: 文本流其实就是一系列字符，可以由多行构成，每行由一个换行符终止。

3、清除浮动(两种情况)
清除浮动包括清除子元素的浮动和清除上级元素的浮动:
清除上级元素的浮动：只需设置clear为both就可以了，
清除子元素的浮动：可以用空标签法、clearfix方法或overflow方法。因清除上级元素的浮动比较简单，而空标签法清除子元素浮动会增加额外标签，所以在这里主要说clearfix方法、overflow方法及偶然发现的inline-block方法。
为什么要清除浮动
一个块级元素的高度如果没有设置height，那么其高度就是由里面的子元素来撑开的，如果子元素使用浮动，脱离了标准的文档流，那么父元素的高度会将其忽略，你可以使用firebug查看下如果不清除浮动，父元素会出现高度不够，那样如果设置border或者background都得不到正确的解析

a.清除子元素浮动clearfix方法
/* 经典版 */ .clearfix:after {     visibility: hidden;     display: block;     font-size: 0;     content: " ";     clear: both;     height: 0; } * html .clearfix             { zoom: 1; } /* IE6 */ *:first-child+html .clearfix { zoom: 1; } /* IE7 */

b.清除子元素浮动overflow方法
/* overflow:auto */ #demo2{     overflow:auto;*zoom:1; } /*或 overflow:hidden */ #demo2{     overflow:hidden;*zoom:1; }
注：方法主要是对父元素设置css，所以不需要加个class，下面的inline-block方法相同，只需设置父元素的css即可
c.清除子元素浮动inline-block方法
#demo3{     display:inline-block;*display:inline;*zoom:1; }
注：这个方法是我在写本文的时候发现的，完美兼容浏览器，因为是偶然发现的，还没有大量运用，所以暂作推荐，有兴趣的可以私下测试，当然它清除的子元素浮动和前面两种还是有点差别的，细心的你早就发现了，前面两个demo比下面的这个demo宽度要大啊呵呵，inline-block正常表现

4、HTML5
文档类型定义,canvas代替flash， <link> 元素的 media 属性,
header,footer,section,article,main,aside,nav,menu,figure,audio,video标签，
表单属性，placeholder，input type(tel,search,url,email,date,number,range,color )
删除 b,font,frame,center,big

5、CSS3
圆角border-radius、阴影box-shadow，text-shadow、渐变gradients、过渡transitions、动画animations、布局multi-columns, flex box, grid layout
Opacity,color(rgb,rgba,hsl,hsla )
子串匹配的属性选择器:
E[attribute^="value"]， E[attribute$="value"]， E[attribute*="value"]。
新的伪类：
:target， :enabled 和 :disabled， :checked， :indeterminate， :root， :nth-child 和 :nth-last-child， :nth-of-type和 :nth-last-of-type， :last-child， :first-of-type 和 :last-of-type， :only-child 和 :only-of-type， :empty， 和 :not。
伪元素使用两个冒号而不是一个来表示：
:after 变为 ::after， :before 变为 ::before， :first-letter 变为 ::first-letter， 还有 :first-line 变为 ::first-line。
新的 general sibling combinator(普通兄弟选择器)  ( h1~pre )
Background:
增加：背景支持各种类型的 <image>， 并不局限于之前定义的 uri()。支持 multiple background images(多背景图片)。
background-repeat 属性的 space 和 round 值，还有支持两个值的语法。
background-attachment local 值。
CSS background-origin， background-size， 和 background-clip 属性。
使用 CSS border-radius， border-top-left-radius， border-top-right-radius， border-bottom-left-radius，和 border-bottom-right-radius 属性来支持带弧度的 border corner(边框角)。
使用 CSS border-image， border-image-source， border-image-slice， border-image-width， border-image-outset， 和 border-image-repeat 属性来支持边框使用 <image>。
支持对装饰行为的定义， 即当 box(元素的框) 被打断(在页面， 列或换行) 时， 使用 CSS box-decoration-break 属性对边框，背景色或图片的定义。
处于风险中： 由于缺少足够的浏览器支持，该特性可能会被推迟到模块的下一个迭代中。
使用 CSS box-shadow 属性来支持元素的阴影。
处于风险中： 由于缺少足够的浏览器支持，该特性的动画效果可能被推迟到模块的下一个迭代中。
Multi-column
增加简单的多列布局， 使用 CSS columns， column-count， column-fill， column-gap， column-rule， column-rule-color， column-rule-style， column-rule-width， column-span， column-width， break-after， break-before， 和break-inside。
CSS value 和units modules
使 initial 和 inherit 关键字能够被用于任意 CSS 属性中。
正式定义了 CSS 2.1 中的 CSS 数据类型，之前是隐晦的由它们的语法记号和文本来定义。
增加：
定义了新的相对字体长度单位：rem 和 ch。
定义了相对视口长度单位：vw， vh， vmax 和 vmin 。
精确了绝对长度单位的实际尺寸，此前它们并非是绝对值，而是使用了 reference pixel(参考像素) 来定义。
定义 <angle>， <time>， <frequency>， <resolution>。
规范 <color>， <image>， 和 <position> 定义的值。
calc()， attr()， 和 toggle() 函数符号的定义。
处于风险中： 由于缺少足够的浏览器支持，calc()， attr()， 和 toggle() 函数符号的标准化可能会被推迟到该模块的下一个迭代中。
Css flexible box layout module
为 CSS display 属性增加了 flexbox layout(伸缩盒布局) 及多个新 CSS 属性来控制它：flex， flex-align， flex-direction， flex-flow， flex-item-align， flex-line-pack， flex-order， flex-pack， 和 flex-wrap。
Css text decoration
扩展：
CSS text-decoration 属性作为 CSS text-decoration-line， text-decoration-color， 和 text-decoration-style 属性的简写形式。并增加了 text-decoration-skip， 和 text-underline-position 属性。
增加：
使用 CSS text-emphasis， text-emphasis-style， text-emphasis-color， 和 text-emphasis-position 属性来支持 East-Asian-script emphasis marks(东亚文本重点符号)。
使用 CSS text-shadow 属性来支持文本的阴影
处于改善阶段的模块(Modules in the refining phase)
增加：
使用 CSS box-sizing 属性来转换盒模型的能力。
处于风险中： 由于缺少足够的浏览器支持 ， padding-box 值的标准化可能会被推迟到该模块的下一个迭代中。
根据表单内容来设置样式， 使用 CSS :indeterminate， :default， :valid， :invalid， :in-range， :out-of-range， :required，:optional， :read-only，和 :read-write 伪类与 ::value， ::choices， ::repeat-item， 和 ::repeat-index 伪元素。
处于风险中： 由于缺少足够的浏览器支持 ，伪元素 ::value， ::choices， ::repeat-item， 和 ::repeat-index 的标准化可能会被推迟到该模块的下一个迭代中。
支持图标，通过 CSS icon 属性定义， 同时在 CSS content 属性中设置新图标的值。
处于风险中： 由于缺少足够的浏览器支持 ，icon 属性和 icon 值的标准化可能会被推迟到 CSS 4 中。
支持 CSS outline-offset 属性， 这样可以对 outline 的位置做更多的控制。
支持 CSS resize 属性， Web 开发者可以控制元素是否能够以及如何调整大小。
支持 CSS text-overflow 属性， 定义文本溢出的行为。
处于风险中： 由于缺少足够的浏览器支持 ，该属性的双值语法也和 <string> 值一样， 它们的标准化可能会被推迟到该模块的下一个迭代中。
定义鼠标 hotspot(热点) 的功能， 扩展了 cursor 属性， 增加了新值：  none, context-menu, cell, vertical-text, alias, copy, no-drop, not-allowed, nesw-resize, nwse-resize, col-resize, row-resize, all-scroll, zoom-in, zoom-out。
指定 sequential navigation order(连续导航顺序， 即 tabbing order(移动顺序)) 的功能， 使用 CSS nav-index， nav-up， nav-right， nav-left， nav-down 属性。
处于风险中： 由于缺少足够的浏览器支持，导航属性的标准化可能会被推迟到该模块的下一个迭代中。
控制 IME editor(输入法编辑器) 使用的功能， 使用 CSS ime-mode 属性。
处于风险中： 由于缺少足够的浏览器支持，ime-mode属性的标准化可能会被推迟到该模块的下一个迭代中。
Transition
通过增加 CSS transition，transition-delay，transition-duration， transition-property，和 transition-timing-function 属性来支持定义两个属性值间的 transitions effects(过渡效果)。
Animation
允许定义动画效果， 借助于新增的 CSS animation， animation-delay， animation-direction， animation-duration， animation-fill-mode，animation-iteration-count， animation-name， animation-play-state， 和 animation-timing-function 属性， 以及 @keyframes @ 规则。
Transform
支持适用于任何元素的 bi-dimensional transforms(二维变形)，使用 CSS transform 和 transform-origin 属性。支持的变形有： matrix()，translate()，translateX()，translateY(， scale()，scaleX()，scaleY()，rotate()，skewX()，和 skewY()。
支持适用于任何元素的 tri-dimensional transforms(三维变形)，使用 CSS  transform-style， perspective， perspective-origin， 和backface-visibility 属性和扩展的 transform 属性，使用以下变形： matrix3d()， translate3d()，translateZ()，scale3d()，scaleZ()，rotate3d()，rotateX() ，rotateY()，rotateZ()，和 perspective()。
Css text
扩展：
CSS text-transform 属性的值 full-width。
CSS text-align 属性的值 start，end，start end，和 match-parent，为包含多个方向文本的文档提供良好支持。
CSS text-align 属性的 <string> 值来根据该字符对齐。对于数字的小数点对齐特别有用。
CSS word-spacing 和 letter-spacing 属性拥有范围限制，来控制两端对齐时的灵活性。
增加：
使用 CSS text-space-collapse 和 tab-size 属性来控制空白该如何显示。
使用 CSS line-break，word-break，hyphens，text-wrap，overflow-wrap，和 text-align-last 属性来控制折行和单词边界。
使用 CSS text-justify 属性来控制两端对齐的行为，这是为了对更多语言类型增加支持。
使用 CSS text-indent 和 hanging-punctuation 属性来控制 edge effect(边缘影响)。
Css fonts
增加：
通过 CSS @font-face @ 规则来支持可下载字体。
借助 CSS font-kerning 属性来控制 contextual inter-glyph spacing(上下文 inter-glyph 间距)。
借助 CSS font-language-override 属性来选择语言指定的字形。
借助 CSS font-feature-settings 属性来选择带有 OpenType 特性的字形。
借助 CSS font-size-adjust 属性来控制当使用 fallback fonts(备用字体) 时的宽高比。
选择替代字体，使用 CSS font-stretch，font-variant-alternates，font-variant-caps，font-variant-east-asian，font-variant-ligatures，font-variant-numeric，和 font-variant-position 属性。还扩展了相关的 CSS font-variant 速记属性，并引入了 @font-features-values @ 规则。
控制自动生成斜体或粗体，当这些字体在 CSS font-synthesis 属性中找不到时。

6、框架 比如less、sass、bootstrap
   混入(Mixins)——class中的class；
   参数混入——可以传递参数的class，就像函数一样；
   嵌套规则——Class中嵌套class，从而减少重复的代码；
   运算——CSS中用上数学；
   颜色功能——可以编辑颜色；
   名字空间(namespace)——分组样式，从而可以被调用；
   作用域——局部修改样式；
   JavaScript 赋值——在CSS中使用JavaScript表达式赋值。

缺点：简单来说CSS预处理器语言较CSS玩法变得更高级了，但同时降低了自己对最终代码的控制力。更致命的是提高了门槛，首先是上手门槛，其次是维护门槛，再来是团队整体水平和规范的门槛。这也造成了初学学习成本的昂贵。
优点：用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。

7、CSS的垂直居中
http://www.smashingmagazine.com/2013/08/09/absolute-horizontal-vertical-centering-css/
1.绝对定位居中(Absolute Centering)技术
我们经常用margin:0 auto来实现水平居中，而一直认为margin:auto不能实现垂直居中……实际上，实现垂直居中仅需要声明元素高度和下面的CSS:
.Absolute-Center {
  margin: auto;
  position: absolute;
  top: 0; left: 0; bottom: 0; right: 0;
}
我不是这种实现方法的第一人，可能这只是非常常见的一种小技术，我斗胆将其命名为绝对居中(Absolute Centering)，虽然如此，但是大多数讨论垂直居中的文章却从来不提这种方法，直到我最近浏览《How to Center Anything WithCSS》这篇文章的评论时候才发现这种用法。在评论列表中Simon和Priit都提及了此方法。
优点：
1.支持跨浏览器，包括IE8-IE10.
2.无需其他特殊标记，CSS代码量少
3.支持百分比%属性值和min-/max-属性
4.只用这一个类可实现任何内容块居中
5.不论是否设置padding都可居中（在不使用box-sizing属性的前提下）
6.内容块可以被重绘。
7.完美支持图片居中。
缺点：
1.必须声明高度（查看可变高度Variable Height）。
2.建议设置overflow:auto来防止内容越界溢出。（查看溢出Overflow）。
3.在Windows Phone设备上不起作用。
浏览器兼容性：
绝对定位方法在最新版的Chrome,Firefox, Safari, Mobile Safari, IE8-10.上均测试通过。
对比表格：
绝对居中法并不是唯一的实现方法，实现垂直居中还有些其他的方法，并各有各的优势。采用哪种技术取决于你的浏览器是否支持和你使用的语言标记。这个对照表有助于你根据自己的需求做出正确的选择。
2、负外边距(Negative Margins)
这或许是当前最流行的使用方法。如果块元素尺寸已知，可以通过以下方式让内容块居中于容器显示：
外边距margin取负数，大小为width/height（不使用box-sizing: border-box时包括padding，）的一半，再加上top: 50%; left: 50%;。
.is-Negative {
        width: 300px;
        height: 200px;
        padding: 20px;
        position: absolute;
        top: 50%; left: 50%;
        margin-left: -170px; /* (width + padding)/2 */
        margin-top: -120px; /* (height + padding)/2 */
}
测试表明，这是唯一在IE6-IE7上也表现良好的方法。
优点：
1. 良好的跨浏览器特性，兼容IE6-IE7。
2. 代码量少。
缺点：
1. 不能自适应。不支持百分比尺寸和min-/max-属性设置。
2. 内容可能溢出容器。
3. 边距大小与padding,和是否定义box-sizing: border-box有关，计算需要根据不同情况。
3、变形（Transforms）
这是最简单的方法，不仅能实现绝对居中同样的效果，也支持联合可变高度方式使用。内容块定义transform: translate(-50%,-50%)必须带上浏览器厂商的前缀，还要加上
top: 50%; left: 50%;
.is-Transformed {
  width: 50%;
  margin: auto;
  position: absolute;
  top: 50%; left: 50%;
  -webkit-transform: translate(-50%,-50%);
      -ms-transform: translate(-50%,-50%);
          transform: translate(-50%,-50%);
}
优点：
1.内容可变高度
2.代码量少
缺点：
1.IE8不支持
2.属性需要写浏览器厂商前缀
3.可能干扰其他transform效果
4.某些情形下会出现文本或元素边界渲染模糊的现象
进一步了解transform实现居中的知识可以参考CSS-Tricks的文章《Centering PercentageWidth/Height Elements》
4、表格单元格（Table-Cell）
总的说来这可能是最好的居中实现方法，因为内容块高度会随着实际内容的高度变化，浏览器对此的兼容性也好。最大的缺点是需要大量额外的标记，需要三层元素让最内层的元素居中。
<div class="Center-Container is-Table">
  <div class="Table-Cell">
    <div class="Center-Block">
    <!-- CONTENT -->
    </div>
  </div>
</div>
.Center-Container.is-Table { display: table; }
.is-Table .Table-Cell {
  display: table-cell;
  vertical-align: middle;
}
.is-Table .Center-Block {
  width: 50%;
  margin: 0 auto;
}
优点：
1.高度可变
2.内容溢出会将父元素撑开。
3.跨浏览器兼容性好。
缺点：
需要额外html标记
了解更多表格单元格实现居中的知识，请参考Roger Johansson发表在456bereastreet的文章《Flexibleheight vertical centering with CSS, beyond IE7》
5、行内块元素（Inline-Block）
很受欢迎的一种居中实现方式，基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央。这个概念的解释可以参考CSS-Tricks上的文章《Centering in the Unknown》
我这个例子也有一些其他地方见不到的小技巧，有助于解决一些小问题。
如果内容块宽度大于容器宽度，比如放了一个很长的文本，但内容块宽度设置最大不能超过容器的100%减去0.25em，否则使用伪元素:after内容块会被挤到容器顶部，使用:before内容块会向下偏移100%。
如果你的内容块需要占据尽可能多的水平空间，可以使用max-width: 99%;（针对较大的容器）或max-width: calc(100% -0.25em)（取决于支持的浏览器和容器宽度）。
<div class="Center-Container is-Inline">
  <div class="Center-Block">
    <!-- CONTENT -->
  </div>
</div>
.Center-Container.is-Inline {
  text-align: center;
  overflow: auto;
}
.Center-Container.is-Inline:after,
.is-Inline .Center-Block {
  display: inline-block;
  vertical-align: middle;
}
.Center-Container.is-Inline:after {
  content: '';
  height: 100%;
  margin-left: -0.25em; /* To offset spacing. May vary by font */
}
.is-Inline .Center-Block {
  max-width: 99%; /* Prevents issues with long content causes the content block to be pushed to the top */
  /* max-width: calc(100% - 0.25em) /* Only for IE9+ */
}
优点：
1.高度可变
2.内容溢出会将父元素撑开。
3.支持跨浏览器，也适应于IE7。
缺点：
1.需要一个容器
2.水平居中依赖于margin-left: -0.25em;该尺寸对于不同的字体/字号需要调整。
3.内容块宽度不能超过容器的100% - 0.25em。
更多相关知识参考ChrisCoyier的文章《Centeringin the Unknown》
6、Flexbox
这是CSS布局未来的趋势。Flexbox是CSS3新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。相关的文章如《Centering Elements with Flexbox》
记住Flexbox不只是用于居中，也可以分栏或者解决一些令人抓狂的布局问题。
body {
   /* Remember to use the other versions for IE 10 and older browsers! */
   display: flex;
   justify-content: center;
   align-items: center;
}
优点：
1.内容块的宽高任意，优雅的溢出。
2.可用于更复杂高级的布局技术中。
缺点：
1. IE8/IE9不支持。
2. Body需要特定的容器和CSS样式。
3.运行于现代浏览器上的代码需要浏览器厂商前缀。
4.表现上可能会有一些问题
有关Flexbox Centering的文章可以参考David Storey的文章《Designing CSS Layouts WithFlexbox Is As Easy As Pie》
建议：
每种技术都有其优劣之处。你选择哪一种技术取决于支持的浏览器和你的编码。使用上面的对照表有助于你做出决定。
其他：
作为一种简单的替代方案，绝对居中(Absolute Centering)技术表现良好。曾经你使用负边距（Negative Margins）的地方，现在可以用绝对居中(Absolute Centering)替代了。你不再需要处理讨厌的边距计算和额外的标记，而且还能让内容块自适应大小居中。
如果你的站点需要可变高度的内容，可以试试单元格(Table-Cell)和行内块元素(Inline-Block)这两种方法。如果你处在流血的边缘，试试Flexbox，体验一下这一高级布局技术的好处吧。












JS部分
1、闭包与作用域 函数部分
下面就是我的学习笔记，对于Javascript初学者应该是很有用的。
一、变量的作用域
要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。
　　var n=999;
　　function f1(){
　　　　alert(n);
　　}
　　f1(); // 999
另一方面，在函数外部自然无法读取函数内的局部变量。
　　function f1(){
　　　　var n=999;
　　}
　　alert(n); // error
这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！
　　function f1(){
　　　　n=999;
　　}
　　f1();
　　alert(n); // 999
二、如何从外部读取局部变量？
出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。
那就是在函数的内部，再定义一个函数。
　　function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}
　　}
在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！
　　function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
三、闭包的概念
上一节代码中的f2函数，就是闭包。
各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
四、闭包的用途
闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
怎么来理解这句话呢？请看下面的代码。
　　function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。
五、使用闭包的注意点
1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
六、思考题
如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。（首先考虑作用域this的指向）
代码片段一。
　　var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());

代码片段二。
　　var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
alert(object.getNameFunc()());
















2、事件 event部分
A、事件流
浏览器中的事件流意味着页面上可有不仅一个，甚至多个元素响应同一个事件。而这一个或多个元素响应事件发生的先后顺序在各个浏览器（主要针对IE和Netscape）上是不同的。
冒泡型事件（Dubbed Bubbling）
IE上的解决方案就是冒泡型事件（Dubbed Bubbling）。冒泡型事件的基本思想是，事件按照从最特定的事件目标到最不特定的事件目标（document对象）的顺序触发。
捕获型事件（Event Capturing）
相对IE4.0，Netscape4.0则使用的是捕获型事件的解决方案。这个事件触发的过程则正好和冒泡相反——在捕获型事件中，事件从最不精确的对象（document对象）开始触发，然后到最精确的对象。还是前面的示例，不过现在换由捕获型事件触发（当然你需要在Netscape或Firefox中测试）。
DOM 事件流
这个事件流则是W3C制定一个标准规范，它同时支持两种事件流模式，不过是先发生捕获型事件流，再发生冒泡型事件流。
DOM事件流最独特的是，它支持文本节点也触发事件（IE中这不支持）。不过说实话，我现在还看不出来让文本节点支持事件有什么作用。
最后要说的是，根据最近大家在开发的实践过程中的运用，我们一般都采取冒泡型的事件流触发方式，这点我们的IE做的比较成功。至于原因，我想你可以通过上面的解释可以看出，毕竟我们给元素触发事件，肯定是希望从我们最希望先触发（从最精确的）的那个开始。

B、事件绑定
事件处理函数/监听函数
一. 在DOM元素中直接绑定
二.  在JavaScript代码中绑定
三. 绑定事件监听函数
四. 这里我不想做过多的介绍，我们知道在IE里使用
具体实践：
attachEvent(”NAME_OF_EVENT_HANDLER”, fnHandler)给元素绑定事件，而在支持DOM事件流的浏览器里，则使用addEventListener(”NAME_OF_EVENT_HANDLER”, fnHandler, isCapture)。前面我控制FIREFOX中触发捕获事件流，就是通过设置isCapture（ture：捕获；false：冒泡）做到的。
function addEvent(obj,type,handle){
try{ // Chrome、FireFox、Opera、Safari、IE9.0及其以上版本
obj.addEventListener(type,handle,false);
}catch(e){
try{ // IE8.0及其以下版本
obj.attachEvent('on' + type,handle);
}catch(e){ // 现代浏览器
obj['on' + type] = handle;
}
}
}
那些事件是支持冒泡，那些不支持？
这个是比较有意思的，这里的总结都来自PPK在YAHOO的演讲《Javascript Event》(推荐大家一定看看，很经典！)，简单总结PPK的内容，基本上只有onload、unload、focus、blur、submit和change事件是不支持冒泡的，这也是我在前面说“一般使用冒泡事件流”。自然向keydown、keypress、keyup、click、dbclick、mousedown、mouseout、mouseover、mouseup、mousemove。用PPK的话说，那就是“Mouse and Key Events”支持冒泡，而Interface Events（也就是《Javascript高级程序设计》里的HTML（HTML是来构建interface的）事件。）则只支持捕获。
他又说了下是，click是“最安全的”事件，它即支持冒泡，又支持捕获。鼠标事件可以触发click，键盘事件也可以触发click。还有就是在支持DOM事件的浏览器里，focus和blur是只支持捕获的，所以如果你如果用到我下面给出的addEvent函数，在给元素绑定focus或则blur事件时，bCapture一定要设置为true。那么这里就发生了一个问题，IE是不支持捕获的，那不是触发不了这连个事件？呵呵，是个严重的问题哦？不过在IE里使用focus和blur事件的时候，其实触发的是IE的focusin和focusout，当然这两个事件也是只支持冒泡的。
PPK虽然这么说，但是我还是想实践一下，于是我这里这么处理了下，window.onfocus = function(){alert('ok')},lnkOne.onfocus = demoClick;有趣的事情发生了！在IE6里，当你点击我的第一个示例链接，呵呵，视乎是即冒泡完了又捕获了，在IE8中则只冒泡了，不过这个只是你点这个链接的时候发生的情况。接着我又算是试探性地“无意中”测试了下，点击其他的应用程序，又一个让我意想不到的情况发生了，居然先触发了window.onfocus，接着触发了lnk.onfocus！！于是我立刻测试了IE6，一样！视乎IE也“疯狂”了一把，触发了onfocus的捕获哦，哈哈！！！难道IE也支持捕获，IE也疯狂？？？！！！！还是这个现象有其他的解释？？疑惑！？！？！！呵呵，起初我确实这么想，让我惊喜了一把，不过仔细想了想，只是事件执行顺序的原因造成了这样的假象。
呵呵，原来在IE6里，点击链接，先触发了onfocus，弹出提示‘A'，然后关闭弹出的提示框窗口时，窗口又获得了焦点，又触发了window的焦点事件。然后是触发了A标签的的click事件，然后关闭弹出的提示窗口时，又让窗口获得了焦点，然后又是A标签获得焦点。而IE8测试正确的，当触发了click事件后，再关闭提示窗口的时候，就不在触发window的focus。哎！空欢喜了一场，我还以为windows的IE支捕`获呢！！不过也不是完全没有收获，如果你也像我这么整了，你要注意IE6会折腾两次的，不过只是在你点击的时候才会这样，如果用tab切换获得焦点，就只会触发A标签的focus事件了。

C、事件委托
//document.onclick，从这点就能看出，这个示例把事件委托放到了document上，即点击document就直接触发我们相应的事件。 document.onclick = function(event){     //IE doesn't pass in the event object     event = event || window.event;          //IE uses srcElement as the target     var target = event.target || event.srcElement;          switch(target.id){         case "help-btn":                 openHelp();                 break;         case "save-btn":                 saveDocument();                 break;         case "undo-btn":                 undoChanges();                 break;         //如果有其元素需要处理点击事件，         //只需要在这里添加不同的case分支就行。     } };

优点：
从“处理速度”、“新增元素事件处理”和“内存消耗”三方面比较了“事件委托”和“事件绑定”的对比，可以很容易看出，“事件委托”在“处理速度”和“内存消耗”上，有得天独厚的优势。所以，在Web编程的时候，尤其在构建大型系统的时候，应该尽量考虑使用“事件委托”。但是，“事件委托”并不是万能的；它也有一些弊端。下面我们在论述一下它的弊端。
缺点：
使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。

D、阻止事件冒泡和阻止事件默认行为
a.阻止事件冒泡
 function stopBubble(e) {
        //如果提供了事件对象，则这是一个非IE浏览器
        if ( e && e.stopPropagation ){
            //因此它支持W3C的stopPropagation()方法
            e.stopPropagation();
        }else{
            //否则，我们需要使用IE的方式来取消事件冒泡
            window.event.cancelBubble = true;
}
}
b.当按键后,不希望按键继续传递给如HTML文本框对象时,可以取消返回值.即停止事件默认行为
//阻止浏览器的默认行为
function stopDefault( e ) {
        //阻止默认浏览器动作(W3C)
        if ( e && e.preventDefault ){
            e.preventDefault();
        //IE中阻止函数器默认动作的方式
        }else{
            window.event.returnValue = false;
    }
}

3、对象，类，继承   对象部分
一、对象的定义，及构造函数 ：Javascript 面向对象编程（一）：封装
Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。
那么，如果我们要把"属性"（property）和"方法"（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？
1、生成对象的原始模式
假定我们把猫看成一个对象，它有"名字"和"颜色"两个属性。
　　var Cat = {
　　　　name : '',
　　　　color : ''
　　}
现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。
　　var cat1 = {}; // 创建一个空对象
　　　　cat1.name = "大毛"; // 按照原型对象的属性赋值
　　　　cat1.color = "黄色";
　　var cat2 = {};
　　　　cat2.name = "二毛";
　　　　cat2.color = "黑色";
好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。
2、原始模式的改进
我们可以写一个函数，解决代码重复的问题。
　　function Cat(name,color){
　　　　return {
　　　　　　name:name,
　　　　　　color:color
　　　　}
　　}
然后生成实例对象，就等于是在调用函数：
　　var cat1 = Cat("大毛","黄色");
　　var cat2 = Cat("二毛","黑色");
这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。
3、构造函数模式
为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。
所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。
比如，猫的原型对象现在可以这样写，
　　function Cat(name,color){
　　　　this.name=name;
　　　　this.color=color;
　　}
我们现在就可以生成实例对象了。
　　var cat1 = new Cat("大毛","黄色");
　　var cat2 = new Cat("二毛","黑色");
　　alert(cat1.name); // 大毛
　　alert(cat1.color); // 黄色
这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。
　　alert(cat1.constructor == Cat); //true
　　alert(cat2.constructor == Cat); //true
Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。
　　alert(cat1 instanceof Cat); //true
　　alert(cat2 instanceof Cat); //true
4、构造函数模式的问题
构造函数方法很好用，但是存在一个浪费内存的问题。
请看，我们现在为Cat对象添加一个不变的属性"type"（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：
　　function Cat(name,color){
　　　　this.name = name;
　　　　this.color = color;
　　　　this.type = "猫科动物";
　　　　this.eat = function(){alert("吃老鼠");};
　　}
还是采用同样的方法，生成实例：
　　var cat1 = new Cat("大毛","黄色");
　　var cat2 = new Cat ("二毛","黑色");
　　alert(cat1.type); // 猫科动物
　　cat1.eat(); // 吃老鼠
表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。
　　alert(cat1.eat == cat2.eat); //false
能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。
5、Prototype模式
Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。
这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。
　　function Cat(name,color){
　　　　this.name = name;
　　　　this.color = color;
　　}
　　Cat.prototype.type = "猫科动物";
　　Cat.prototype.eat = function(){alert("吃老鼠")};
然后，生成实例。
　　var cat1 = new Cat("大毛","黄色");
　　var cat2 = new Cat("二毛","黑色");
　　alert(cat1.type); // 猫科动物
　　cat1.eat(); // 吃老鼠
这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。
　　alert(cat1.eat == cat2.eat); //true
6、Prototype模式的验证方法
为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，
6.1 isPrototypeOf()
这个方法用来判断，某个proptotype对象和某个实例之间的关系。
　　alert(Cat.prototype.isPrototypeOf(cat1)); //true
　　alert(Cat.prototype.isPrototypeOf(cat2)); //true
6.2 hasOwnProperty()
每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。
　　alert(cat1.hasOwnProperty("name")); // true
　　alert(cat1.hasOwnProperty("type")); // false
6.3 in运算符
in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。
　　alert("name" in cat1); // true
　　alert("type" in cat1); // true
in运算符还可以用来遍历某个对象的所有属性。
　　for(var prop in cat1) { alert("cat1["+prop+"]="+cat1[prop]); }

二、对象构造函数的继承   Javascript面向对象编程（二）：构造函数的继承
这个系列的第一部分，主要介绍了如何"封装"数据和方法，以及如何从原型对象生成实例。
今天要介绍的是，对象之间的"继承"的五种方法。
比如，现在有一个"动物"对象的构造函数。
　　function Animal(){
　　　　this.species = "动物";
　　}
还有一个"猫"对象的构造函数。
　　function Cat(name,color){
　　　　this.name = name;
　　　　this.color = color;
　　}
怎样才能使"猫"继承"动物"呢？
1、构造函数绑定
第一种方法也是最简单的方法，使用call（子对象，单个参数）或apply（子对象，数组参数）方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：
　　function Cat(name,color){
　　　　Animal.apply(this, arguments);
　　　　this.name = name;
　　　　this.color = color;
　　}
　　var cat1 = new Cat("大毛","黄色");
　　alert(cat1.species); // 动物
2、prototype模式
第二种方法更常见，使用prototype属性。
如果"猫"的prototype对象，指向一个Animal的实例，那么所有"猫"的实例，就能继承Animal了。
　　Cat.prototype = new Animal();
　　Cat.prototype.constructor = Cat;
　　var cat1 = new Cat("大毛","黄色");
　　alert(cat1.species); // 动物
代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。
　　Cat.prototype = new Animal();
它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？
　　Cat.prototype.constructor = Cat;
原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有"Cat.prototype = new Animal();"这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。
　　alert(Cat.prototype.constructor == Animal); //true
更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。
　　alert(cat1.constructor == Cat.prototype.constructor); // true
因此，在运行"Cat.prototype = new Animal();"这一行之后，cat1.constructor也指向Animal！
　　alert(cat1.constructor == Animal); // true
这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。
很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，
　　o.prototype = {};
那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。
　　o.prototype.constructor = o;
3、直接继承prototype
第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。
现在，我们先将Animal对象改写：
　　function Animal(){ }
　　Animal.prototype.species = "动物";
然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。
　　Cat.prototype = Animal.prototype;
　　Cat.prototype.constructor = Cat;
　　var cat1 = new Cat("大毛","黄色");
　　alert(cat1.species); // 动物
与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。
所以，上面这一段代码其实是有问题的。请看第二行
　　Cat.prototype.constructor = Cat;
这一句实际上把Animal.prototype对象的constructor属性也改掉了！
　　alert(Animal.prototype.constructor); // Cat
4、利用空对象作为中介
由于"直接继承prototype"存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。
　　var F = function(){};
　　F.prototype = Animal.prototype;
　　Cat.prototype = new F();
　　Cat.prototype.constructor = Cat;
F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。
　　alert(Animal.prototype.constructor); // Animal
我们将上面的方法，封装成一个函数，便于使用。
　　function extend(Child, Parent) {

　　　　var F = function(){};
　　　　F.prototype = Parent.prototype;
　　　　Child.prototype = new F();
　　　　Child.prototype.constructor = Child;
　　　　Child.uber = Parent.prototype;
　　}
使用的时候，方法如下
　　extend(Cat,Animal);
　　var cat1 = new Cat("大毛","黄色");
　　alert(cat1.species); // 动物
这个extend函数，就是YUI库如何实现继承的方法。
另外，说明一点，函数体最后一行
　　Child.uber = Parent.prototype;
意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是"向上"、"上一层"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。
5、拷贝继承
上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用"拷贝"方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。
首先，还是把Animal的所有不变属性，都放到它的prototype对象上。
　　function Animal(){}
　　Animal.prototype.species = "动物";
然后，再写一个函数，实现属性拷贝的目的。
　　function extend2(Child, Parent) {
　　　　var p = Parent.prototype;
　　　　var c = Child.prototype;
　　　　for (var i in p) {
　　　　　　c[i] = p[i];
　　　　　　}
　　　　return c;
　　}
这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。（但这里for in 属于浅拷贝，因为for in 会遍历圆形链上的属性）
使用的时候，这样写：
　　extend2(Cat, Animal);
　　var cat1 = new Cat("大毛","黄色");
alert(cat1.species); // 动物

三、非构造函数的继承    Javascript面向对象编程（三）：非构造函数的继承
这个系列的第一部分介绍了"封装"，第二部分介绍了使用构造函数实现"继承"。
今天是最后一个部分，介绍不使用构造函数实现"继承"。
1、什么是"非构造函数"的继承？
比如，现在有一个对象，叫做"中国人"。
　　var Chinese = {
　　　　nation:'中国'
　　};
还有一个对象，叫做"医生"。
　　var Doctor ={
　　　　career:'医生'
　　}
请问怎样才能让"医生"去继承"中国人"，也就是说，我怎样才能生成一个"中国医生"的对象？
这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现"继承"。
2、object()方法 返回new原型对象的方法   （创建jquery对象就是用这个原理，但多了一步判断）
json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。
　　function object(o) {
　　　　function F() {}
　　　　F.prototype = o;
　　　　return new F();
　　}
这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。
使用的时候，第一步先在父对象的基础上，生成子对象：
　　var Doctor = object(Chinese);
然后，再加上子对象本身的属性：
　　Doctor.career = '医生';
这时，子对象已经继承了父对象的属性了。
　　alert(Doctor.nation); //中国

3、object.create()方法
a.在父对象：
var Chinese={"nation":"中国"};
b.建立子对象：
var Doctor= Object.create(Chinese);
c.再加上子对象本身的属性：
Doctor.career = '医生';
这时，子对象已经继承了父对象的属性了。
console.log(Doctor.nation + Doctor.career);//中国医生

4、浅拷贝
除了使用"prototype链"以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。
下面这个函数，就是在做拷贝：
　　function extendCopy(p) {
　　　　var c = {};
　　　　for (var i in p) {
　　　　　　c[i] = p[i];
　　　　}
　　　　return c;
　　}
使用的时候，这样写：
　　var Doctor = extendCopy(Chinese);
　　Doctor.career = '医生';
　　alert(Doctor.nation); // 中国
但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。
请看，现在给Chinese添加一个"出生地"属性，它的值是一个数组。
　　Chinese.birthPlaces = ['北京','上海','香港'];
通过extendCopy()函数，Doctor继承了Chinese。
　　var Doctor = extendCopy(Chinese);
然后，我们为Doctor的"出生地"添加一个城市：
　　Doctor.birthPlaces.push('厦门');
发生了什么事？Chinese的"出生地"也被改掉了！
　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
　　alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门
所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做"浅拷贝"。这是早期jQuery实现继承的方式。

5、深拷贝
所谓"深拷贝"，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用"浅拷贝"就行了。
　　function deepCopy(p, c) {
　　　　var c = c || {};
　　　　for (var i in p) {
　　　　　　if (typeof p[i] === 'object') {
　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : {};
　　　　　　　　deepCopy(p[i], c[i]);
　　　　　　} else {
　　　　　　　　　c[i] = p[i];
　　　　　　}
　　　　}
　　　　return c;
　　}
使用的时候这样写：
　　var Doctor = deepCopy(Chinese);
现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：
　　Chinese.birthPlaces = ['北京','上海','香港'];
　　Doctor.birthPlaces.push('厦门');
这时，父对象就不会受到影响了。
　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
　　alert(Chinese.birthPlaces); //北京, 上海, 香港
目前，jQuery库使用的就是这种继承方法。


4、http请求和ajax 以及ajax跨域
1、HTTP请求
超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。
HTTP 的工作方式是客户机与服务器之间的请求-应答协议。
两种 HTTP 请求方法：GET 和 POST
a.GET 方法
请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：
/test/demo_form.asp?name1=value1&name2=value2
有关 GET 请求的其他一些注释：
GET 请求可被缓存
GET 请求保留在浏览器历史记录中
GET 请求可被收藏为书签
GET 请求不应在处理敏感数据时使用
GET 请求有长度限制
GET 请求只应当用于取回数据
b.POST 方法
请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
有关 POST 请求的其他一些注释：
POST 请求不会被缓存
POST 请求不会保留在浏览器历史记录中
POST 不能被收藏为书签
POST 请求对数据长度没有要求



2、AJAX

AJAX (异步 JavaScript 和 XML) 是个新产生的术语,专为描述JavaScript的两项强大性能.这两项性能在多年来一直被网络开发者所忽略,直到最近Gmail, Google Suggest和Google Maps的横空出世才使人们开始意识到其重要性.
这两项被忽视的性能是:
无需重新装载整个页面便能向服务器发送请求.
对XML文档的解析和处理

1、步骤 1 – "请!" --- 如何发送一个HTTP请求
为了用JavaScript向服务器发送一个HTTP请求, 需要一个具备这种功能的类实例. 这样的类首先由Internet Explorer以ActiveX对象引入, 被称为XMLHTTP. 后来Mozilla, Safari 和其他浏览器纷纷仿效, 提供了XMLHttpRequest类,它支持微软的ActiveX对象所提供的方法和属性.
A、创建一个跨浏览器的这样的类实例(对象), 可以应用如下代码:
if (window.XMLHttpRequest) { // Mozilla, Safari, ...     http_request = new XMLHttpRequest(); } else if (window.ActiveXObject) { // IE     http_request = new ActiveXObject("Microsoft.XMLHTTP"); }
(上例对代码做了一定简化,这是为了解释如何创建XMLHTTP类实例. 实际的代码实例可参阅本篇步骤3.)
如果服务器的响应没有XML mime-type header,某些Mozilla浏览器可能无法正常工作. 为了解决这个问题, 如果服务器响应的header不是text/xml,可以调用其它方法修改该header.

http_request = new XMLHttpRequest(); http_request.overrideMimeType('text/xml');
B、决定当收到服务器的响应后,需要做什么.这需要告诉HTTP请求对象用哪一个JavaScript函数处理这个响应.可以将对象的onreadystatechange属性设置为要使用的JavaScript的函数名,如下所示:

http_request.onreadystatechange = nameOfTheFunction;
注意:在函数名后没有括号,也无需传递参数.另外还有一种方法,你可以使用一个匿名函数来描述那些要对服务器返回的响应内容所进行的操作,如下所示:

http_request.onreadystatechange = function(){     // do the thing };
C、在定义了如何处理响应后,就要发送请求了.可以调用HTTP请求类的open()和send()方法, 如下所示:

http_request.open('GET', 'http://www.example.org/some.file', true); http_request.send(null);
open()的第一个参数是HTTP请求方式 – GET, POST, HEAD 或任何服务器所支持的您想调用的方式. 按照HTTP规范,该参数要大写;否则,某些浏览器(如Firefox)可能无法处理请求.有关HTTP请求方法的详细信息可参考http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html

第二个参数是请求页面的URL.由于自身安全特性的限制,该页面不能为第三方域名的页面.同时一定要保证在所有的页面中都使用准确的域名,否则调用open()会得到"permission denied"的错误提示.一个常见的错误是访问站点时使用domain.tld,而当请求页面时,却使用www.domain.tld.

第三个参数设置请求是否为异步模式.如果是TRUE, JavaScript函数将继续执行,而不等待服务器响应.这就是"AJAX"中的"A".
如果第一个参数是"GET",通过open()第二个参数，传递参数，一般用于查询，jsonp的跨域就是这个原理，也只能解决get方式的请求；
如果第一个参数是"POST",send()方法的参数可以是任何想送给服务器的数据. 这时数据要以字符串的形式送给服务器,如下所示:
name=value&anothername=othervalue&so=on
2、步骤 2 – "收到!" --- 处理服务器的响应
当发送请求时,要提供指定处理响应的JavaScript函数名.
http_request.onreadystatechange = nameOfTheFunction;
我们来看看这个函数的功能是什么.首先函数会检查请求的状态.如果状态值是4,就意味着一个完整的服务器响应已经收到了,您将可以处理该响应.

if (http_request.readyState == 4) {     // everything is good, the response is received } else {     // still not ready }
readyState的取值如下:
0 (未初始化)
1 (正在装载)
2 (装载完毕)
3 (交互中)
4 (完成)
(Source)
接着,函数会检查HTTP服务器响应的状态值. 完整的状态取值可参见 W3C site. 我们着重看值为200 OK的响应.

if (http_request.status == 200) {     // perfect! } else {     // there was a problem with the request,     // for example the response may be a 404 (Not Found)     // or 500 (Internal Server Error) response codes }
在检查完请求的状态值和响应的HTTP状态值后, 您就可以处理从服务器得到的数据了.有两种方式可以得到这些数据:
http_request.responseText – 以文本字符串的方式返回服务器的响应
http_request.responseXML – 以XMLDocument对象方式返回响应.处理XMLDocument对象可以用JavaScript DOM函数

3、步骤 3 – "万事俱备!" - 简单实例
我们现在将整个过程完整地做一次,发送一个简单的HTTP请求. 我们用JavaScript请求一个HTML文件, test.html, 文件的文本内容为"I'm a test.".然后我们"alert()"test.html文件的内容.
<script type="text/javascript" language="javascript">      var http_request = false;      function makeRequest(url) {          http_request = false;          if (window.XMLHttpRequest) { // Mozilla, Safari,...            http_request = new XMLHttpRequest();             if (http_request.overrideMimeType) {                 http_request.overrideMimeType('text/xml');             }         } else if (window.ActiveXObject) { // IE            try {                 http_request = new ActiveXObject("Msxml2.XMLHTTP");             } catch (e) {                 try {                     http_request = new ActiveXObject("Microsoft.XMLHTTP");                 } catch (e) {}             }         }          if (!http_request) {             alert('Giving up :( Cannot create an XMLHTTP instance');             return false;         }         http_request.onreadystatechange = alertContents;         http_request.open('GET', url, true);         http_request.send(null);      }      function alertContents() {          if (http_request.readyState == 4) {             if (http_request.status == 200) {                 alert(http_request.responseText);             } else {                 alert('There was a problem with the request.');             }         }      }</script><span     style="cursor: pointer; text-decoration: underline"     onclick="makeRequest('test.html')">         Make a request</span>
本例中:
用户点击浏览器上的"请求"链接;
接着函数makeRequest()将被调用.其参数 – HTML文件test.html在同一目录下;
这样就发起了一个请求.onreadystatechange的执行结果会被传送给alertContents();
alertContents()将检查服务器的响应是否成功地收到,如果是,就会"alert()"test.html文件的内容.


3、Ajax的跨域
概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。
URL                      说明       是否允许通信 http://www.a.com/a.js http://www.a.com/b.js     同一域名下   允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js     同一域名，不同端口  不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许
对于端口和协议的不同，只能通过后台来解决。
A、跨域资源共享（CORS）
CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。
<script type="text/javascript">     var xhr = new XMLHttpRequest();     xhr.open("￼GET", "/trigkit4",true);     xhr.send();</script>
以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：
<script type="text/javascript">     var xhr = new XMLHttpRequest();     xhr.open("￼GET", "http://segmentfault.com/u/trigkit4/",true);     xhr.send();</script>
代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。
服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

要解决跨域的问题，我们可以使用以下几种方法：
B、通过jsonp跨域
现在问题来了？什么是jsonp？维基百科的定义是：JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。
JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如: callback({"name","trigkit4"});
JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。

在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：
<script type="text/javascript">     function dosomething(jsondata){         //处理获得的json数据     }</script>
<script src="http://example.com/data.php?callback=dosomething"></script>
js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。

<?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?>
最终，输出结果为：dosomething(['a','b','c']);

如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。

<script type="text/javascript">     $.getJSON('http://example.com/data.php?callback=?,function(jsondata)'){         //处理获得的json数据     });</script>
jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。
JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。
JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
CORS和JSONP对比
CORS与JSONP相比，无疑更为先进、方便和可靠。
1、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。 2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。 3、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。

C、通过修改document.domain来跨子域
浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。
不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.example.com/a.html ， 在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：
<script type="text/javascript">     function test(){         var iframe = document.getElementById('￼ifame');         var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的         var doc = win.document;//这里获取不到iframe里的document对象         var name = win.name;//这里同样获取不到window对象的name属性     }</script>
<iframe id = "iframe" src="http://example.com/b.html" onload = "test()"></iframe>
这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。
1.在页面 http://www.example.com/a.html 中设置document.domain:
<iframe id = "iframe" src="http://example.com/b.html" onload = "test()"></iframe>
<script type="text/javascript">     document.domain = 'example.com';//设置成主域     function test(){         alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象     }</script>
2.在页面 http://example.com/b.html 中也设置document.domain:
<script type="text/javascript">     document.domain = 'example.com';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</script>
修改document.domain的方法只适用于不同子域的框架间的交互。

D、使用window.name来进行跨域
window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的

E、使用HTML5的window.postMessage方法跨域
window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
4、框架 比如angular、ember、backbone
5、集成工具 yeoman、bower、grunt， git, stackflow
6、其他部分
1、Hybrid app
2、未来方向

7、数组对象
1、基本方法：
Push ,unshift, pop, shift, for ,forin,toString()
Jion,reverse,sort,concat,slice,splice
forEach,map,filter,every,some,reduce,reduceRight,indexof

2、判断是否数组：
Array.isArray([]);
X instenceof Array
({}).tostring.apply([]) === ‘[object Array]’
[].constructor === Array

3、基本数组，二维数组，稀疏数组



